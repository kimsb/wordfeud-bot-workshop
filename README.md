# Wordfeud-bot

I dag skal du f√• lage din helt egen Wordfeud-bot!

Algoritmen som vi skal implementere ble beskrevet i artikkelen [The World‚Äôs Fastest Scrabble Program](https://www.cs.cmu.edu/afs/cs/academic/class/15451-s06/www/lectures/scrabble.pdf) helt tilbake i 1988 ü§Ø

Det er en ganske snedig algoritme som finner alle gyldige legg. Med noen enkle steg reduseres problemet v√•rt til √©n dimensjon, slik at vi bare trenger √• finne alle gyldige legg for √©n enkelt rad om gangen. I Wordfeud kan man enten legge brikker horisontalt eller vertikalt, men dersom man tenker p√• et vertikalt legg som et horisontalt legg p√• et transponert brett, trenger vi bare √• implementere algoritmen for √• finne alle gyldige horisontale legg.

**F√∏r kodingen starter kan du g√• til fila `Bot` og sette variabelen `botName` til navnet p√• boten din (jeg har allerede opprettet Wordfeud-brukere til alle p√• formatet `<navn>bot` (uten √Ü√ò√Ö), dvs at f.eks J√∏rgen har en bruker som heter `jorgenbot`). Pr√∏v √• bygge og kj√∏re prosjektet for √• se at innlogging funker!**

## Anchors

Det f√∏rste vi skal gj√∏re er √• finne ut hvilke felter som er s√•kalte `anchors`, dvs hvilke felter som kan v√¶re utgangspunkt for neste legg. Ethvert legg i Wordfeud m√• bygge videre p√• brikkene som allerede ligger p√• brettet, s√• et felt er klassifisert som `anchor` dersom
- ingen brikke er plassert p√• feltet
- det er plassert en brikke p√• et eller flere av feltene rundt brikken (over, under, venstre, h√∏yre)

I `Board`-klassen sin konstrukt√∏r blir brettet fylt med brikkene fra Wordfeud-apiet. G√• til `Board` sin `init` og sett riktig `isAnchor` for hver `Square`.
Dersom det ikke er noen brikker p√• brettet, skal det midterste feltet `squares[7][7]` v√¶re `anchor`

For √• teste koden kan vi kj√∏re `Anchors`-testene i `BoardTest`. (Testene blir ikke kj√∏rt ved bygg.)

<details>
  <summary>Eksempel p√• implementasjon av init</summary>
    
  ```kotlin
init {
        this.squares = squares.mapIndexed { i, row ->
            row.mapIndexed { j, square ->
                square.copy(isAnchor = !squares[i][j].isOccupied() &&
                    ((i == 7 && j == 7) ||
                        squares.getOrNull(i - 1)?.get(j)?.isOccupied() == true ||
                        squares[i].getOrNull(j - 1)?.isOccupied() == true ||
                        squares[i].getOrNull(j + 1)?.isOccupied() == true ||
                        squares.getOrNull(i + 1)?.get(j)?.isOccupied() == true))
            }
        }
    }
  ```
  
</details>

## Cross-Checks

For hvert horisontalt legg m√• vi ogs√• s√∏rge for at brikkene vi legger former gyldige ord vertikalt n√•r de legges inntil andre brikker. `Square` har en variabel `crossChecks` som er et `BitSet` som skal representere hvilke bokstaver vi kan legge for √• forme gyldige ord vertikalt. `crossCheks` har st√∏rrelse 26, for de 26 bokstavene man kan legge i Wordfeud (disse er definert i `VALID_LETTERS` i fila `Constants`). G√• til klassen `Row` (Det kan v√¶re litt forvirrende at man skal finne cross-checks horisontalt, n√•r jeg har nevnt at vi skal finne gyldige ord vertikalt, men det er fordi vi ser p√• kolonner som transponerte rader...). Her skal du implementere funksjonen `crossChecks()` og fylle ut riktig `BitSet` for hver `Square`. Her f√•r du bruk for funksjonene `getPrefix()` og `getSuffix()`. 

For hver `Square` finnes det tre alternativer:
- Det finnes allerede en brikke p√• feltet (ingen bokstaver kan legges)
- Feltet har ingen prefix eller suffix (alle bokstaver kan legges)
- Feltet har prefix og/eller suffix (da m√• man for alle `VALID_LETTERS` L sjekke om `prefix + L + suffix` former gyldige ord)

For √• sjekke om et ord er gyldig, brukes `Dictionary.contains()`

For √• teste koden kan vi kj√∏re `Cross-checks`-testen i `RowTest`. (Testen blir ikke kj√∏rt ved bygg.)

<details>
  <summary>Eksempel p√• implementasjon av crossChecks()</summary>
    
  ```kotlin
fun crossChecks(): List<Square> {
        return squares.mapIndexed { squareIndex, square ->
            val bitSet = BitSet(26)
            if (!square.isOccupied()) {
                val prefix = getPrefix(squareIndex)
                val suffix = getSuffix(squareIndex)
                if (prefix.isEmpty() && suffix.isEmpty()) {
                    bitSet.flip(0, 26)
                } else {
                    VALID_LETTERS.forEachIndexed { bitSetIndex, letter ->
                        bitSet.set(bitSetIndex, contains(prefix + letter + suffix))
                    }
                }
            }
            square.copy(crossChecks = bitSet)
        }
    }
  ```
  
</details>

## Across moves

(Det som beskrives under her finnes i funksjonen `findAcrossMoves()` som allerede er implementert i klassen `Row`...)

For hver `anchor` skal vi finne alle `left parts` av ord som ligger til venstre for `anchor`, og deretter skal vi for hver `left part` finne alle matchende `right parts`. Den venstre delen av ordet best√•r enten av brikker som allerede ligger p√• brettet, eller brikker som du har p√• racket ditt, aldri fra begge deler.
Dersom den venstre delen av ordet kommer fra brettet, kan vi bare bruke `getPrefix()` og finne alle matchende h√∏yre deler for `prefix`, men hvis den venstre delen skal komme fra brettet m√• vi finne alle mulige `left parts`. En `left part` kan ikke krysse et `anchor`, s√• den er dermed begrenset av hvor mange felter den har til venstre, som ikke er `anchors`. Dette gir oss en `limit` som vi bruker n√•r vi skal finne alle `left parts`

## Left part

Her skal vi implementere funksjonen `leftPart()` i klassen `Row`. Den finner alle gyldige `left parts` og kaller s√• p√• funskjonen `extendRight()` (som vi skal implementere etterp√•) for hver `left part` den finner.

Her er pseudokode av funskjonen, som beskrevet i artikkelen nevnt over

```
LeftPart(PartialWord, node N in DAWG, limit) = 
  ExtendRight(PartialWord, N, Anchorsquare)
  if limit > 0 then
    for each edge E out of N
        if the letter L labeling edge E is in our rack then
          remove a tile labeled L from the rack
          let N' be the node reached by following egde E
          Leftpart(PartialWord + L, N', limit - 1)
          put the tile L back into the rack
```

I koden v√•r sender vi ogs√• med `anchorIndex` som lar hos holde styr p√• hvilken `Square` som er `anchor`, og `rack` som representerer racket v√•rt.
Siden `Rack` er immutable, trenger vi ikke fjerne/legge tilbake brikker p√• racket, men vi kan bruke `Rack` sin funksjon `without()` som returnerer et nytt `Rack` uten brikken som vi √∏nsker √• fjerne, n√•r vi kaller p√• neste `leftPart()`. Vi kan bruke `outgoingTransitions` for √• finne edges ut av en `MDAGNode`.

<details>
  <summary>Eksempel p√• implementasjon av leftPart()</summary>
    
  ```kotlin
private fun leftPart(
        partialWord: String,
        node: MDAGNode,
        limit: Int,
        anchorIndex: Int,
        rack: Rack
    ) {
        extendRight(partialWord, node, anchorIndex, anchorIndex, rack)
        if (limit > 0) {
            node.outgoingTransitions.entries.forEach {
                if (rack.contains(it.key)) {
                    leftPart(partialWord + it.key, it.value, limit - 1, anchorIndex, rack.without(it.key))
                }
            }
        }
    }
  ```
  
</details>


## Extend right

For hver `left part` blir det gjort et kall p√• `extendRight()` for √• fullf√∏re ord, og det er den funksjonen vi skal implementere her.
I motsetning til en `left part` kan en h√∏yre del av et ord best√• av b√•de brikker fra racket og brikker som allerede ligger p√• brettet.

Her er pseudokode av funskjonen, som beskrevet i artikkelen nevnt over

```
ExtendRight(PartialWord, node N in DAWG, square)
if square is vacant then
    if N is a terminal node then
        LegalMove(PartialWord)
    for each edge E out of N
        if the letter L labeling edge E is in our rack AND L is in the cross-check set of square then
            remove a tile L from the rack
            let N' be the node reached by following edge E
            let next-square be the square to the right of square
            ExtendRight(PartialWord + L, N', next-square)
            put the tile L back into the rack
else
    let L be the letter occupying square
    if N has an edge labeled by L that leads to some node N' then
        let next-square be the square to the right of square
        ExtendRight(PartialWord + L, N', next-square)
```

Vi kan bruke `isAcceptNode` for √• finne ut om en `MDAGNode` er en `terminal node`.

I koden v√•r tilsvarer `LegalMove(PartialWord)` √• legge til en ny `RowMove` i listen `rowMoves`

For √• f√• sjekket for `terminal node` ogs√• p√• siste felt kan det v√¶re lurt √• legge til et tomt felt p√• enden av hver rad, ved f.eks √• gj√∏re noe s√•nt som dette
```kotlin
val square = squares.getOrElse(index) { Square() }
```

For √• finne ut om en bokstav er en del av `crossChecks` kan vi bruke `Square` sin `crossChecksContains()`

For √• teste koden kan vi kj√∏re testen `Find all words` i `BoardTest`. (Testen blir ikke kj√∏rt ved bygg)

<details>
  <summary>Eksempel p√• implementasjon av extendRight()</summary>
    
  ```kotlin
private fun extendRight(
        partialWord: String,
        node: MDAGNode,
        anchorIndex: Int,
        index: Int,
        rack: Rack
    ) {
        val square = squares.getOrElse(index) { Square() }
        if (!square.isOccupied()) {
            if (index != anchorIndex && node.isAcceptNode) {
                rowMoves.add(RowMove(partialWord,
                    index - partialWord.length,
                    calculateScore(partialWord, index - partialWord.length)))
            }
            node.outgoingTransitions.entries.forEach {
                if (rack.contains(it.key) && square.crossChecksContains(it.key)) {
                    extendRight(partialWord + it.key, it.value, anchorIndex, index + 1, rack.without(it.key))
                }
            }
        } else {
            square.getLetter()?.let {
                if (node.hasOutgoingTransition(it)) {
                    extendRight(partialWord + it, node.transition(it), anchorIndex, index + 1, rack)
                }
            }
        }
    }
  ```
  
</details>

**WOHOO!**
N√• har du faktisk en bot som kj√∏rer!
Meeen den har fortsatt en del forbedringspotensiale...
Den klarer ikke bruke blanke brikker (som er de beste brikkene) og den vet ikke hvor mange poeng hvert legg gir, s√• den legger bare det f√∏rste ordet den finner...

## Blanke brikker

For √• finne absolutt alle mulige legg, m√• boten l√¶re seg √• bruke blanke brikker.
Det fikser vi ved √• legge til litt ekstra logikk i b√•de `leftPart()` og `extendRight()`.
Etter vi har sjekket om racket v√•rt inneholder en gitt bokstav, sjekker vi ogs√• om racket inneholder en blank brikke (representert av `'*'`)
Dersom vi har en blank brikke bruker vi den som bokstaven vi har sjekket for (f.eks P), men vi setter den da til `lowerCase` for √• differensiere bruk av blank brikke med bruk av vanlig bokstav.

For √• teste koden kan vi kj√∏re testen `Find all words with blank` i `BoardTest`. (Testen blir ikke kj√∏rt ved bygg)

Str√•lende! N√• finner vi ALLE mulige legg! Men det hadde v√¶rt fint √• vite hvor mange poeng hvert legg gir...

<details>
  <summary>Eksempel p√• implementasjon av leftPart() med st√∏tte for blank brikke</summary>
    
  ```kotlin
private fun leftPart(
        partialWord: String,
        node: MDAGNode,
        limit: Int,
        anchorIndex: Int,
        rack: Rack
    ) {
        extendRight(partialWord, node, anchorIndex, anchorIndex, rack)
        if (limit > 0) {
            node.outgoingTransitions.entries.forEach {
                if (rack.contains(it.key)) {
                    leftPart(partialWord + it.key, it.value, limit - 1, anchorIndex, rack.without(it.key))
                }
                if (rack.contains('*')) {
                    leftPart(partialWord + it.key.toLowerCase(), it.value, limit - 1, anchorIndex, rack.without('*'))
                }
            }
        }
    }
  ```
  
</details>

<details>
  <summary>Eksempel p√• implementasjon av extendRight() med st√∏tte for blank brikke</summary>
    
  ```kotlin
private fun extendRight(
        partialWord: String,
        node: MDAGNode,
        anchorIndex: Int,
        index: Int,
        rack: Rack
    ) {
        val square = squares.getOrElse(index) { Square() }
        if (!square.isOccupied()) {
            if (index != anchorIndex && node.isAcceptNode) {
                rowMoves.add(RowMove(partialWord,
                    index - partialWord.length,
                    calculateScore(partialWord, index - partialWord.length)))
            }
            node.outgoingTransitions.entries.forEach {
                if (rack.contains(it.key) && square.crossChecksContains(it.key)) {
                    extendRight(partialWord + it.key, it.value, anchorIndex, index + 1, rack.without(it.key))
                }
                if (rack.contains('*') && square.crossChecksContains(it.key)) {
                    extendRight(partialWord + it.key.toLowerCase(), it.value, anchorIndex, index + 1, rack.without('*'))
                }
            }
        } else {
            square.getLetter()?.let {
                if (node.hasOutgoingTransition(it)) {
                    extendRight(partialWord + it, node.transition(it), anchorIndex, index + 1, rack)
                }
            }
        }
    }
  ```
  
</details>

## Poeng

For hvert horisontale legg m√• vi telle poeng for ordene som blir laget vertikalt ogs√•. F√∏rste steg for √• regne ut poengsummen for hvert legg blir derfor √• regne ut `crossSum` for hver `Square`. `crossSum` er poengsummen til alle bokstavene som allerede ligger p√• brettet over og under et gitt felt, og som vil bli til et vertikalt ord. `crossSum` kan vi finne ved √• legge til noen linjer i funksjonen `crossChecks()` som vi implementerte tidligere.
`crossSum` skal settes til summen av alle bokstavene i `prefix` og `suffix`, eller `null` dersom feltet allerede er opptatt eller hvis feltet hverken har `prefix` eller `suffix`.

For √• teste koden kan vi kj√∏re testene `Cross sums` i `RowTest`. (Testene blir ikke kj√∏rt ved bygg)

<details>
  <summary>Eksempel p√• implementasjon av crossChecks() med crossSum</summary>
    
  ```kotlin
fun crossChecks(): List<Square> {
        return squares.mapIndexed { squareIndex, square ->
            val bitSet = BitSet(26)
            var crossSum: Int? = null
            if (!square.isOccupied()) {
                val prefix = getPrefix(squareIndex)
                val suffix = getSuffix(squareIndex)
                if (prefix.isEmpty() && suffix.isEmpty()) {
                    bitSet.flip(0, 26)
                } else {
                    VALID_LETTERS.forEachIndexed { bitSetIndex, letter ->
                        bitSet.set(bitSetIndex, contains(prefix + letter + suffix))
                    }
                    crossSum = if ((prefix + suffix).isEmpty()) null else (prefix + suffix).map(Constants::letterScore).sum()
                }
            }
            square.copy(crossChecks = bitSet, crossSum = crossSum)
        }
    }
  ```
  
</details>

YES! Da gjenst√•r det √• regne ut poengsummen for hele legget, det gj√∏r vi i funksjonen `calculateScore()` i `Row`. For hvert felt som er en del av det nye, vertikale legget gjelder:
- dersom feltet allerede har en brikke, ta med poengsummen til den brikken i den vertikale summen
- dersom en brikke fra racket blir brukt, ta med poengsummen til den brikken + evt `letterMultiplier`/`wordMultiplier` i b√•de vertikal og horisontal sum

`letterMultiplier` gjelder for √©n brikke, dvs dersom du legger en B (som gir 4 poeng) p√• et felt med `letterMultiplier` = 2, s√• skal brikken gi 8 poeng (i begge retninger).

`wordMultiplier` gjelder for hele ordet (i begge retninger), dvs dersom du legger B√Ü (som gir 4 + 8 = 12 poeng) over et felt med `wordMultiplier` = 2, s√• skal ordet gi 24 poeng.

Dersom alle 7 brikkene fra racket blir brukt (dette kalles en `bingo`), skal vi gi 40 poeng ekstra

For √• teste koden kan vi kj√∏re testene `Calculate score` i `BoardTest`. (Testene blir ikke kj√∏rt ved bygg)

<details>
  <summary>Eksempel p√• implementasjon av calculateScore()</summary>
    
  ```kotlin
private fun calculateScore(word: String, startIndex: Int): Int {
        var wordMultiplier = 1
        var crossSums = 0
        var addedLetters = 0
        return squares.subList(startIndex, startIndex + word.length).mapIndexed { index, square ->
            if (square.isOccupied()) {
                letterScore(square.getLetter()!!)
            } else {
                addedLetters++
                wordMultiplier *= square.wordMultiplier
                val squareScore = letterScore(word[index]) * square.letterMultiplier
                if (square.crossSum != null) {
                    crossSums += (squareScore + square.crossSum) * square.wordMultiplier
                }
                squareScore
            }
        }.sum() * wordMultiplier + crossSums + (if (addedLetters == 7) 40 else 0)
    }
  ```
  
</details>


## Strategi

WOW! üî•
N√• har vi en bot som ALLTID finner det h√∏yeste scorende legget!
Det m√• jo bli suksess, eller? I de fleste tilfeller vil en slik strategi v√¶re nok til √• gj√∏re det veldig bra, men det finnes fortsatt forbedringspotensiale!
Her er noen f√• tips til forbedringer:
- Bytting av brikker: n√•r b√∏r man bytte og hvilke brikker b√∏r man bytte? N√• bytter boten bare hvis den ikke finner et eneste gyldig legg.
- Spare fine brikker: noen ganger er det l√∏nnsomt √• kvitte seg med d√•rlige brikker, selv om man f√•r litt mindre poeng.
- Bare bruke blank brikke n√•r man f√•r godt betalt for det
- Ikke √•pne for mye: det hjelper ikke √• f√• noen f√• ekstra poeng om man samtidig serverer motstanderen mye mer
- Sluttspill: mot slutten av spillet vet man hvilke brikker motstanderen sitter igjen med. Kanskje kan man blokke, slik at motstanderen ikke kan bli kvitt sine brikker?
